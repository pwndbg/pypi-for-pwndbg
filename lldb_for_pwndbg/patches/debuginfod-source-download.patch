--- a/lldb/include/lldb/lldb-private-interfaces.h
+++ b/lldb/include/lldb/lldb-private-interfaces.h
@@ -98,6 +98,8 @@
     const FileSpec &dsym_bundle_fspec, const UUID *uuid, const ArchSpec *arch);
 typedef std::optional<FileSpec> (*SymbolLocatorLocateExecutableSymbolFile)(
     const ModuleSpec &module_spec, const FileSpecList &default_search_paths);
+typedef std::optional<FileSpec> (*SymbolLocatorLocateSourceFile)(
+    const ModuleSpec &module_spec, const FileSpec &file_spec);
 typedef bool (*SymbolLocatorDownloadObjectAndSymbolFile)(
     ModuleSpec &module_spec, Status &error, bool force_lookup,
     bool copy_executable);
--- a/lldb/include/lldb/Core/PluginManager.h
+++ b/lldb/include/lldb/Core/PluginManager.h
@@ -438,6 +438,7 @@
       SymbolLocatorDownloadObjectAndSymbolFile download_object_symbol_file =
           nullptr,
       SymbolLocatorFindSymbolFileInBundle find_symbol_file_in_bundle = nullptr,
+      SymbolLocatorLocateSourceFile locate_source_file = nullptr,
       DebuggerInitializeCallback debugger_init_callback = nullptr);
 
   static bool UnregisterPlugin(SymbolLocatorCreateInstance create_callback);
@@ -461,6 +462,9 @@
   static FileSpec FindSymbolFileInBundle(const FileSpec &dsym_bundle_fspec,
                                          const UUID *uuid,
                                          const ArchSpec *arch);
+
+  static std::optional<FileSpec> LocateSourceFile(const ModuleSpec &module_spec,
+                                                  const FileSpec &file_spec);
 
   // Trace
   static bool RegisterPlugin(
--- a/lldb/source/Core/PluginManager.cpp
+++ b/lldb/source/Core/PluginManager.cpp
@@ -1418,18 +1418,21 @@
       SymbolLocatorLocateExecutableSymbolFile locate_executable_symbol_file,
       SymbolLocatorDownloadObjectAndSymbolFile download_object_symbol_file,
       SymbolLocatorFindSymbolFileInBundle find_symbol_file_in_bundle,
+      SymbolLocatorLocateSourceFile locate_source_file,
       DebuggerInitializeCallback debugger_init_callback)
       : PluginInstance<SymbolLocatorCreateInstance>(
             name, description, create_callback, debugger_init_callback),
         locate_executable_object_file(locate_executable_object_file),
         locate_executable_symbol_file(locate_executable_symbol_file),
         download_object_symbol_file(download_object_symbol_file),
-        find_symbol_file_in_bundle(find_symbol_file_in_bundle) {}
+        find_symbol_file_in_bundle(find_symbol_file_in_bundle),
+        locate_source_file(locate_source_file) {}
 
   SymbolLocatorLocateExecutableObjectFile locate_executable_object_file;
   SymbolLocatorLocateExecutableSymbolFile locate_executable_symbol_file;
   SymbolLocatorDownloadObjectAndSymbolFile download_object_symbol_file;
   SymbolLocatorFindSymbolFileInBundle find_symbol_file_in_bundle;
+  SymbolLocatorLocateSourceFile locate_source_file;
 };
 typedef PluginInstances<SymbolLocatorInstance> SymbolLocatorInstances;
 
@@ -1445,11 +1448,12 @@
     SymbolLocatorLocateExecutableSymbolFile locate_executable_symbol_file,
     SymbolLocatorDownloadObjectAndSymbolFile download_object_symbol_file,
     SymbolLocatorFindSymbolFileInBundle find_symbol_file_in_bundle,
+    SymbolLocatorLocateSourceFile locate_source_file,
     DebuggerInitializeCallback debugger_init_callback) {
   return GetSymbolLocatorInstances().RegisterPlugin(
       name, description, create_callback, locate_executable_object_file,
       locate_executable_symbol_file, download_object_symbol_file,
-      find_symbol_file_in_bundle, debugger_init_callback);
+      find_symbol_file_in_bundle, locate_source_file, debugger_init_callback);
 }
 
 bool PluginManager::UnregisterPlugin(
@@ -1533,6 +1537,23 @@
   return {};
 }
 
+std::optional<FileSpec>
+PluginManager::LocateSourceFile(const ModuleSpec &module_spec,
+                                const FileSpec &file_spec) {
+  auto instances = GetSymbolLocatorInstances().GetSnapshot();
+  for (auto &instance : instances) {
+    if (instance.locate_source_file) {
+      std::optional<FileSpec> result;
+      {
+        result = instance.locate_source_file(module_spec, file_spec);
+      }
+      if (result)
+        return *result;
+    }
+  }
+  return std::nullopt;
+}
+
 #pragma mark Trace
 
 struct TraceInstance
--- a/lldb/source/Core/SourceManager.cpp
+++ b/lldb/source/Core/SourceManager.cpp
@@ -13,6 +13,7 @@
 #include "lldb/Core/Debugger.h"
 #include "lldb/Core/FormatEntity.h"
 #include "lldb/Core/Highlighter.h"
+#include "lldb/Core/PluginManager.h"
 #include "lldb/Core/Module.h"
 #include "lldb/Core/ModuleList.h"
 #include "lldb/Host/FileSystem.h"
@@ -540,6 +541,35 @@
           if (remapped)
             SetSupportFile(std::make_shared<SupportFile>(
                 *remapped, support_file_sp->GetChecksum()));
+        }
+      }
+
+      // Try Plugins
+      {
+        FileSpec file_spec = GetSupportFile()->GetSpecOnly();
+        if (!FileSystem::Instance().Exists(file_spec)) {
+          bool check_inlines = false;
+          SymbolContextList sc_list;
+          size_t num_matches =
+              target_sp->GetImages().ResolveSymbolContextForFilePath(
+                  file_spec.GetFilename().AsCString(), 0, check_inlines,
+                  eSymbolContextModule | eSymbolContextCompUnit, sc_list);
+          if (num_matches > 0) {
+            SymbolContext sc;
+            sc_list.GetContextAtIndex(0, sc);
+            ModuleSpec module_spec;
+            module_spec.GetUUID() = sc.module_sp->GetUUID();
+            const std::optional<FileSpec> result =
+                PluginManager::LocateSourceFile(module_spec, file_spec);
+            if (result.has_value()) {
+              SetSupportFile(std::make_shared<SupportFile>(
+                  *result, support_file_sp->GetChecksum()));
+              // Map original DWARF path â†’ cache path so that
+              // GetLineEntry().GetFileSpec() resolves to an existing file.
+              target_sp->GetSourcePathMap().AppendUnique(
+                  file_spec.GetPath(), result->GetPath(), /*notify=*/true);
+            }
+          }
         }
       }
     }
--- a/lldb/source/Target/StackFrame.cpp
+++ b/lldb/source/Target/StackFrame.cpp
@@ -12,7 +12,11 @@
 #include "lldb/Core/FormatEntity.h"
 #include "lldb/Core/Mangled.h"
 #include "lldb/Core/Module.h"
+#include "lldb/Core/ModuleList.h"
+#include "lldb/Core/PluginManager.h"
 #include "lldb/Core/Value.h"
+#include "lldb/Host/FileSystem.h"
+#include "llvm/Debuginfod/Debuginfod.h"
 #include "lldb/Symbol/CompileUnit.h"
 #include "lldb/Symbol/Function.h"
 #include "lldb/Symbol/Symbol.h"
@@ -400,6 +404,28 @@
             !m_sc.line_entry.IsValid()) {
           m_sc.line_entry = sc.line_entry;
           m_sc.line_entry.ApplyFileMappings(m_sc.target_sp);
+          // If file still doesn't exist locally and debuginfod is usable,
+          // try symbol locator plugins and re-apply file mappings.
+          // Guards are ordered cheapest-first: canUseDebuginfod() and
+          // GetEnableExternalLookup() are cheap boolean checks that avoid
+          // the stat() and plugin overhead in the common case where
+          // debuginfod is not configured or external lookup is disabled.
+          if (m_sc.target_sp && m_sc.module_sp &&
+              llvm::canUseDebuginfod() &&
+              ModuleList::GetGlobalModuleListProperties()
+                  .GetEnableExternalLookup() &&
+              !FileSystem::Instance().Exists(m_sc.line_entry.GetFile())) {
+            ModuleSpec mod_spec;
+            mod_spec.GetUUID() = m_sc.module_sp->GetUUID();
+            if (auto result = PluginManager::LocateSourceFile(
+                    mod_spec,
+                    m_sc.line_entry.original_file_sp->GetSpecOnly())) {
+              m_sc.target_sp->GetSourcePathMap().AppendUnique(
+                  m_sc.line_entry.original_file_sp->GetSpecOnly().GetPath(),
+                  result->GetPath(), /*notify=*/false);
+              m_sc.line_entry.ApplyFileMappings(m_sc.target_sp);
+            }
+          }
         }
       }
     } else {
--- a/lldb/source/Plugins/SymbolLocator/Debuginfod/SymbolLocatorDebuginfod.h
+++ b/lldb/source/Plugins/SymbolLocator/Debuginfod/SymbolLocatorDebuginfod.h
@@ -47,6 +47,9 @@
   static std::optional<FileSpec>
   LocateExecutableSymbolFile(const ModuleSpec &module_spec,
                              const FileSpecList &default_search_paths);
+
+  static std::optional<FileSpec> LocateSourceFile(const ModuleSpec &module_spec,
+                                                  const FileSpec &file_spec);
 };
 
 } // namespace lldb_private
--- a/lldb/source/Plugins/SymbolLocator/Debuginfod/SymbolLocatorDebuginfod.cpp
+++ b/lldb/source/Plugins/SymbolLocator/Debuginfod/SymbolLocatorDebuginfod.cpp
@@ -16,6 +16,9 @@

 #include "llvm/Debuginfod/Debuginfod.h"
 #include "llvm/Debuginfod/HTTPClient.h"
+#include "llvm/ADT/StringExtras.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/Path.h"

 using namespace lldb;
 using namespace lldb_private;
@@ -112,7 +115,7 @@
     PluginManager::RegisterPlugin(
         GetPluginNameStatic(), GetPluginDescriptionStatic(), CreateInstance,
         LocateExecutableObjectFile, LocateExecutableSymbolFile, nullptr,
-        nullptr, SymbolLocatorDebuginfod::DebuggerInitialize);
+        nullptr, LocateSourceFile, SymbolLocatorDebuginfod::DebuggerInitialize);
     llvm::HTTPClient::initialize();
   });
 }
@@ -210,3 +213,83 @@
     const ModuleSpec &module_spec, const FileSpecList &default_search_paths) {
   return GetFileForModule(module_spec, llvm::getDebuginfodDebuginfoUrlPath);
 }
+
+// Returns the cache path for a source file with a human-readable filename:
+//   <cache_dir>/sources/<build_id_hex>/source-<djb2_hash>-<escaped_path>
+// e.g. ~/.cache/llvm-debuginfod/client/sources/66cd4a.../source-8612e4f5-#usr#src#...#shell.c
+static llvm::SmallString<256>
+getNiceSourceCachePath(llvm::StringRef cache_base,
+                       llvm::object::BuildIDRef build_id,
+                       llvm::StringRef file_path) {
+  // DJB2 hash (DJBX33A) of the full original path.
+  uint32_t Hash = 5381;
+  for (unsigned char Ch : file_path)
+    Hash = ((Hash << 5) + Hash) + Ch;
+  // Escape path: keep A-Z a-z 0-9 . - _ ; replace everything else with #.
+  std::string Escaped;
+  Escaped.reserve(file_path.size());
+  for (unsigned char Ch : file_path) {
+    if ((Ch >= 'A' && Ch <= 'Z') || (Ch >= 'a' && Ch <= 'z') ||
+        (Ch >= '0' && Ch <= '9') || Ch == '.' || Ch == '-' || Ch == '_')
+      Escaped += Ch;
+    else
+      Escaped += '#';
+  }
+  // Truncate from the front to stay within filename length limits (NAME_MAX).
+  const size_t MaxSuffix = 118; // 255 - len("source-deadbeef-")
+  if (Escaped.size() > MaxSuffix)
+    Escaped = Escaped.substr(Escaped.size() - MaxSuffix);
+  char Prefix[18];
+  snprintf(Prefix, sizeof(Prefix), "source-%08x-", Hash);
+  llvm::SmallString<256> NicePath(cache_base);
+  llvm::sys::path::append(NicePath, "sources",
+                          llvm::toHex(build_id, /*LowerCase=*/true),
+                          std::string(Prefix) + Escaped);
+  return NicePath;
+}
+
+std::optional<FileSpec>
+SymbolLocatorDebuginfod::LocateSourceFile(const ModuleSpec &module_spec,
+                                          const FileSpec &file_spec) {
+  const UUID &module_uuid = module_spec.GetUUID();
+  const std::string file_path = file_spec.GetPath();
+  if (file_path.empty() || !module_uuid.IsValid() ||
+      !llvm::canUseDebuginfod() ||
+      !ModuleList::GetGlobalModuleListProperties().GetEnableExternalLookup())
+    return {};
+
+  llvm::object::BuildID build_id(module_uuid.GetBytes());
+
+  PluginProperties &plugin_props = GetGlobalPluginProperties();
+  llvm::Expected<std::string> cache_path_or_err = plugin_props.GetCachePath();
+  if (!cache_path_or_err)
+    return {};
+
+  llvm::SmallString<256> NicePath =
+      getNiceSourceCachePath(*cache_path_or_err, build_id, file_path);
+
+  // Cache hit: nice file already exists, return it directly.
+  if (llvm::sys::fs::exists(NicePath))
+    return FileSpec(NicePath.str());
+
+  // Download via debuginfod, then move to the nice path.
+  std::string url_path = llvm::getDebuginfodSourceUrlPath(build_id, file_path);
+  llvm::SmallVector<llvm::StringRef> debuginfod_urls =
+      llvm::getDefaultDebuginfodUrls();
+  std::chrono::milliseconds timeout = plugin_props.GetTimeout();
+  llvm::Expected<std::string> Downloaded = llvm::getCachedOrDownloadArtifact(
+      llvm::getDebuginfodCacheKey(url_path), url_path, *cache_path_or_err,
+      debuginfod_urls, timeout);
+  if (!Downloaded) {
+    Log *log = GetLog(LLDBLog::Source);
+    LLDB_LOGV(log, "Debuginfod failed to download source file {0} with error {1}",
+              file_path, llvm::toString(Downloaded.takeError()));
+    return std::nullopt;
+  }
+
+  llvm::sys::fs::create_directories(llvm::sys::path::parent_path(NicePath));
+  if (!llvm::sys::fs::rename(*Downloaded, NicePath))
+    return FileSpec(NicePath.str());
+
+  return FileSpec(*Downloaded);
+}
